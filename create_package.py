#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Script to generate a skeleton for a new Python package.

Features:
    - Sphinx docs
    - Read the Docs setup
    - Travis setup
    - Poetry initialization
    - Makefile
    - MANIFEST.in
    - Green for unit tests

Author: Gertjan van den Burg

"""

import argparse
import os
import subprocess
import license
import tomlkit
import git


class NonZeroExitStatus(Exception):
    pass


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--url", help="Package URL", default="")
    parser.add_argument("pkgname", help="Package name")
    return parser.parse_args()


def mkdir(name):
    os.makedirs(name, exist_ok=True)


def cd(name):
    os.chdir(name)


def pyproject_get(key):
    if key == "author_name":
        authors = pyproject_get("tool.poetry.authors")
        return authors[0].split("<")[0].strip()
    if key == "author_email":
        authors = pyproject_get("tool.poetry.authors")
        return authors[0].split("<")[1].rstrip(">").strip()
    with open("./pyproject.toml", "r") as fp:
        data = tomlkit.parse(fp.read())
    parts = key.split(".")
    table, name = parts[:-1], parts[-1]
    while table:
        data = data[table.pop(0)]
    return data[name]


def create_package(pkgname):
    status = subprocess.call(["poetry", "init", "--name", pkgname])
    if not status == 0:
        raise NonZeroExitStatus(f"poetry init --name {pkgname}")
    status = subprocess.call(["poetry", "add", "-D", "green", "m2r"])
    if not status == 0:
        raise NonZeroExitStatus(f"poetry add -D green m2r")
    mkdir(pkgname)
    with open(f"{pkgname}/__init__.py", "w") as fp:
        fp.write("# -*- coding: utf-8 -*-\n\n")
        fp.write("from .__version__ import __version__")
    version = pyproject_get("tool.poetry.version")
    parts = version.split(".")
    with open(f"{pkgname}/__version__.py", "w") as fp:
        fp.write("# -*- coding: utf-8 -*-\n\n")
        fp.write(f"VERSION = ({', '.join(parts)})\n\n")
        fp.write('__version__ = ".".join(map(str, VERSION))')


def create_makefile(pkgname):
    contents = f"""\
# Makefile for easier installation and cleanup.
#
# Uses self-documenting macros from here:
# http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html

PACKAGE={pkgname}
DOC_DIR='./docs/'

.PHONY: help cover dist

.DEFAULT_GOAL := help

help:
\t@grep -E '^[0-9a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) |\\
         awk 'BEGIN {{FS = ":.*?## "}}; {{printf "\\033[36m%-15s\\033[0m\\
         %s\\n", $$1, $$2}}'

release: ## Make a release
\tpython make_release.py

in: inplace
inplace: ## Build package in place
\tpython setup.py build_ext -i

install: requirements.txt ## Install for the current user using the default python command
\tpython setup.py build_ext --inplace
\tpython setup.py install --user

test: inplace ## Run unit tests
\tpoetry run green -v ./tests

clean: ## Clean build dist and egg directories left after install
\trm -rf ./dist ./build ./$(PACKAGE).egg-info
\trm -f MANIFEST
\trm -f ./$(PACKAGE)/*.so
\trm -f ./*_valgrind.log*
\tfind . -type f -iname '*.pyc' -delete
\tfind . -type d -name '__pycache__' -empty -delete

develop: ## Install a development version of the package needed for testing
\tpython setup.py develop --user

dist: requirements.txt ## Make Python source distribution
\tpython setup.py sdist

docs: install ## Build documentation with Sphinx
\tpoetry run m2r README.md && mv README.rst $(DOC_DIR)
\tpoetry run m2r CHANGELOG.md && mv CHANGELOG.rst $(DOC_DIR)
\tcd $(DOC_DIR) && \\
\t    rm source/* && \\
\t    sphinx-apidoc -H 'API Documentation' -o source ../$(PACKAGE) && \\
\t	touch source/AUTOGENERATED_DO_NOT_EDIT
\t$(MAKE) -C $(DOC_DIR) html

requirements.txt: pyproject.toml
\tpoetry run pip freeze | grep -v {pkgname} > $@
    """
    with open("Makefile", "w") as fp:
        fp.write(contents)


def create_manifest_in(pkgname):
    contents = f"""\
include setup.py
include README.md
include LICENSE
include requirements.txt
recursive-include {pkgname} *.py
recursive-include src *.c
recursive-include tests *.py
exclude poetry.lock
exclude pyproject.toml
exclude Makefile
exclude .gitignore
exclude .travis.yml
    """
    with open("MANIFEST.in", "w") as fp:
        fp.write(contents)


def create_docs(pkgname):
    author = pyproject_get("author_name")
    mkdir("docs")
    cd("docs")
    mkdir("source")
    mkdir("_build")
    mkdir("_static")
    mkdir("_templates")
    confcontents = f"""\
# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# http://www.sphinx-doc.org/en/master/config

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
import sys

sys.path.insert(0, os.path.abspath("."))


# -- Project information -----------------------------------------------------

project = "{pkgname}"
copyright = "2019, {author}"
author = "{author}"


# -- General configuration ---------------------------------------------------

master_doc = 'index'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.coverage",
    "sphinx.ext.napoleon",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_rtd_theme"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]
    """
    with open("conf.py", "w") as fp:
        fp.write(confcontents)
    index = f"""\
.. include:: ./readme.rst

.. toctree::
   :maxdepth: 2

   readme

.. toctree::
   :caption: Further Documentation
   :maxdepth: 2

   changelog
   source/modules


Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
    """
    with open("index.rst", "w") as fp:
        fp.write(index)

    makebat = """\
@ECHO OFF\r\r
pushd %~dp0\r\r
REM Command file for Sphinx documentation\r\r
if "%SPHINXBUILD%" == "" (\r
    set SPHINXBUILD=sphinx-build\r
)\r
set SOURCEDIR=.\r
set BUILDDIR=_build\r
\r
if "%1" == "" goto help\r
\r
%SPHINXBUILD% >NUL 2>NUL\r
if errorlevel 9009 (\r
    echo.\r
    echo.The 'sphinx-build' command was not found. Make sure you have Sphinx\r
    echo.installed, then set the SPHINXBUILD environment variable to point\r
    echo.to the full path of the 'sphinx-build' executable. Alternatively you\r
    echo.may add the Sphinx directory to PATH.\r
    echo.\r
    echo.If you don't have Sphinx installed, grab it from\r
    echo.http://sphinx-doc.org/\r
    exit /b 1\r
)\r
\r
%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%\r
goto end\r
\r
:help\r
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%\r
\r
:end\r
popd\r
    """
    with open("make.bat", "w") as fp:
        fp.write(makebat)
    makefile = """
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
    """
    with open("Makefile", "w") as fp:
        fp.write(makefile)
    with open("changelog.rst", "w") as fp:
        fp.write(".. include:: ./CHANGELOG.rst")
    with open("readme.rst", "w") as fp:
        fp.write(".. include:: ./README.rst")
    cd("..")


def create_setup(pkgname, url=""):
    lic = license.find(pyproject_get("tool.poetry.license"))
    desc = pyproject_get("tool.poetry.description")
    author_email = pyproject_get("author_email")
    author = pyproject_get("author_name")
    contents = f"""\
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import io
import os
import sys
from shutil import rmtree

from setuptools import find_packages, setup, Command
from distutils.extension import Extension

# Package meta-data.
NAME = "{pkgname}"
DESCRIPTION = "{desc}"
URL = "{url}"
EMAIL = "{author_email}"
AUTHOR = "{author}"
REQUIRES_PYTHON = ">=3.0.0"
VERSION = None

# What packages are required for this module to be executed?
REQUIRED = []

# What packages are optional?
EXTRAS = {{}}

# The rest you shouldn't have to touch too much :)
# ------------------------------------------------
# Except, perhaps the License and Trove Classifiers!
# If you do change the License, remember to change the Trove Classifier for that!

here = os.path.abspath(os.path.dirname(__file__))

# Import the README and use it as the long-description.
# Note: this will only work if 'README.md' is present in your MANIFEST.in file!
try:
    with io.open(os.path.join(here, "README.md"), encoding="utf-8") as f:
        long_description = "\\n" + f.read()
except FileNotFoundError:
    long_description = DESCRIPTION

try:
    with io.open(os.path.join(here, 'requirements.txt'), encoding='utf-8') as f:
        REQUIRED = [l.strip() for l in f.readlines()]
except FileNotFoundError:
    pass

# Load the package's __version__.py module as a dictionary.
about = {{}}
if not VERSION:
    project_slug = NAME.lower().replace("-", "_").replace(" ", "_")
    with open(os.path.join(here, project_slug, "__version__.py")) as f:
        exec(f.read(), about)
else:
    about["__version__"] = VERSION


# Where the magic happens:
setup(
    name=NAME,
    version=about["__version__"],
    description=DESCRIPTION,
    long_description=long_description,
    long_description_content_type="text/markdown",
    author=AUTHOR,
    author_email=EMAIL,
    python_requires=REQUIRES_PYTHON,
    url=URL,
    packages=find_packages(
        exclude=["tests", "*.tests", "*.tests.*", "tests.*"]
    ),
    install_requires=REQUIRED,
    extras_require=EXTRAS,
    include_package_data=True,
    license="{lic.id}",
    ext_modules=[],
    classifiers=[
        # Trove classifiers
        # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers
        "{lic.python}",
        "Programming Language :: Python",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: Implementation :: CPython",
        "Programming Language :: Python :: Implementation :: PyPy",
    ],
)
    """
    with open("setup.py", "w") as fp:
        fp.write(contents)


def create_release_script():
    contents = """\
#!/usr/bin/env python
# -*- coding: utf-8 -*-

\"\"\"
Do-nothing script for making a release

This idea comes from here:
https://blog.danslimmon.com/2019/07/15/do-nothing-scripting-the-key-to-gradual-automation/

Author: Gertjan van den Burg
Date: 2019-07-23

\"\"\"

import colorama
import os


def colored(msg, color=None, style=None):
    colors = {
        "red": colorama.Fore.RED,
        "green": colorama.Fore.GREEN,
        "cyan": colorama.Fore.CYAN,
        "yellow": colorama.Fore.YELLOW,
        "magenta": colorama.Fore.MAGENTA,
        None: "",
    }
    styles = {
        "bright": colorama.Style.BRIGHT,
        "dim": colorama.Style.DIM,
        None: "",
    }
    pre = colors[color] + styles[style]
    post = colorama.Style.RESET_ALL
    return f"{{pre}}{{msg}}{{post}}"


def cprint(msg, color=None, style=None):
    print(colored(msg, color=color, style=style))


def wait_for_enter():
    input(colored("\\nPress Enter to continue", style="dim"))
    print()


def get_package_name():
    with open("./pyproject.toml", "r") as fp:
        nameline = next(
            (l.strip() for l in fp if l.startswith("name = ")), None
        )
        return nameline.split("=")[-1].strip().strip('"')


class Step:
    def pre(self, context):
        pass

    def post(self, context):
        wait_for_enter()

    def run(self, context):
        try:
            self.pre(context)
            self.action(context)
            self.post(context)
        except KeyboardInterrupt:
            cprint("\\nInterrupted.", color="red")
            raise SystemExit(1)

    def instruct(self, msg):
        cprint(msg, color="green")

    def print_run(self, msg):
        cprint("Run:", color="cyan", style="bright")
        self.print_cmd(msg)

    def print_cmd(self, msg):
        cprint("\\t" + msg, color="cyan", style="bright")

    def do_cmd(self, cmd):
        cprint(f"Going to run: {{cmd}}", color="magenta", style="bright")
        wait_for_enter()
        os.system(cmd)


class GitToMaster(Step):
    def action(self, context):
        self.instruct("Make sure you're on master and changes are merged in")
        self.print_run("git checkout master")


class UpdateChangelog(Step):
    def action(self, context):
        self.instruct(f"Update change log for version {{context['version']}}")
        self.print_run("vi CHANGELOG.md")


class RunTests(Step):
    def action(self, context):
        self.do_cmd("make test")


class BumpVersionPoetry(Step):
    def action(self, context):
        self.instruct("Bump poetry version (<version> = patch/minor/major)")
        self.print_run("poetry version <version>")

    def post(self, context):
        wait_for_enter()
        context["version"] = self._get_version()

    def _get_version(self):
        # Get the version from pyproject.toml
        with open("./pyproject.toml", "r") as fp:
            versionline = next(
                (l.strip() for l in fp if l.startswith("version")), None
            )
        version = versionline.split("=")[-1].strip().strip('"')
        return version


class BumpVersionPackage(Step):
    def action(self, context):
        self.instruct(
            f"Update __version__.py with version: {{context['version']}}"
        )
        self.print_run(f"vi {{context['pkgname']}}/__version__.py")


class MakeClean(Step):
    def action(self, context):
        self.do_cmd("make clean")


class MakeDocs(Step):
    def action(self, context):
        self.do_cmd("make docs")


class MakeDist(Step):
    def action(self, context):
        self.do_cmd("make dist")


class PushToTestPyPI(Step):
    def action(self, context):
        self.do_cmd(
            "twine upload --repository-url https://test.pypi.org/legacy/ dist/*"
        )


class InstallFromTestPyPI(Step):
    def action(self, context):
        self.print_run("cd /tmp/")
        self.print_cmd("rm -rf ./venv")
        self.print_cmd("virtualenv ./venv")
        self.print_cmd("cd ./venv")
        self.print_cmd("source bin/activate")
        self.print_cmd(
            "pip install --index-url https://test.pypi.org/simple/ "
            + f"--extra-index-url https://pypi.org/simple {{context['pkgname']}}=={{context['version']}}"
        )


class TestCleverCSV(Step):
    def action(self, context):
        self.instruct(
            f"Ensure that the following command gives version {{context['version']}}"
        )
        self.print_run(f"{{context['pkgname']}} -V")


class DeactivateVenv(Step):
    def action(self, context):
        self.print_run("deactivate")
        self.instruct("Go back to the project directory")


class GitTagVersion(Step):
    def action(self, context):
        self.do_cmd(f"git tag v{{context['version']}}")


class GitAdd(Step):
    def action(self, context):
        self.instruct("Add everything to git and commit")
        self.print_run("git gui")


class PushToPyPI(Step):
    def action(self, context):
        self.do_cmd("twine upload dist/*")


class PushToGitHub(Step):
    def action(self, context):
        self.do_cmd("git push -u --tags origin master")


class WaitForTravis(Step):
    def action(self, context):
        self.instruct(
            "Wait for Travis to complete and verify that its successful"
        )


class WaitForRTD(Step):
    def action(self, context):
        self.instruct(
            "Wait for ReadTheDocs to complete and verify that its successful"
        )


def main():
    colorama.init()
    procedure = [
        GitToMaster(),
        GitAdd(),
        PushToGitHub(),
        WaitForTravis(),
        WaitForRTD(),
        BumpVersionPoetry(),
        BumpVersionPackage(),
        UpdateChangelog(),
        MakeClean(),
        RunTests(),
        MakeDocs(),
        MakeDist(),
        PushToTestPyPI(),
        InstallFromTestPyPI(),
        TestCleverCSV(),
        DeactivateVenv(),
        GitAdd(),
        PushToPyPI(),
        GitTagVersion(),
        PushToGitHub(),
    ]
    context = {{}}
    context["pkgname"] = get_package_name()
    for step in procedure:
        step.run(context)
    cprint("\\nDone!", color="yellow", style="bright")


if __name__ == "__main__":
    main()

    """
    with open("make_release.py", "w") as fp:
        fp.write(contents)


def create_changelog():
    version = pyproject_get("tool.poetry.version")
    with open("CHANGELOG.md", "w") as fp:
        fp.write("# Changelog\n\n")
        fp.write(f"## Version {version}\n\n")
        fp.write("* Initial version.")


def create_readme(pkgname):
    with open("README.md", "w") as fp:
        fp.write(f"# {pkgname}")


def create_rtd_config():
    contents = """\
# Read the Docs configuration file
#
version: 2

sphinx:
  configuration: docs/conf.py

formats: all

python:
  version: 3.6
  install:
    - method: setuptools
      path: .
    - requirements: requirements.txt

    """
    with open(".readthedocs.yml", "w") as fp:
        fp.write(contents)


def create_travis_config():
    pyversion = pyproject_get("tool.poetry.dependencies.python")
    pyversion = pyversion.lstrip("^")
    contents = f"""\
language: python
python:
  - "{pyversion}"

install:
  - pip install --upgrade pip
  - curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python
  - source $HOME/.poetry/env
  - poetry install
  - python setup.py build_ext --inplace

script:
  - make test
    """
    with open(".travis.yml", "w") as fp:
        fp.write(contents)


def create_gitignore(pkgname):
    with open(".gitignore", "w") as fp:
        fp.write("*/__pycache__/\n")
        fp.write("*.pyc\n")
        fp.write("build\n")
        fp.write("dist\n")
        fp.write(f"{pkgname}.egg-info\n")
        fp.write("docs/_build\n")
        fp.write("docs/_static\n")


def setup_git(pkgname):
    repo = git.Repo.init(".")
    repo.index.add(
        [
            pkgname,
            "docs",
            "CHANGELOG.md",
            "README.md",
            "Makefile",
            "make_release.py",
            "MANIFEST.in",
            "pyproject.toml",
            "poetry.lock",
            "setup.py",
            ".readthedocs.yml",
            ".travis.yml",
            ".gitignore",
        ]
    )
    repo.index.commit("initial commit")


def main():
    args = parse_args()
    mkdir(args.pkgname)
    cd(args.pkgname)

    create_package(args.pkgname)
    create_makefile(args.pkgname)
    create_manifest_in(args.pkgname)
    create_docs(args.pkgname)
    create_setup(args.pkgname, args.url)
    create_release_script()
    create_changelog()
    create_readme(args.pkgname)
    create_rtd_config()
    create_travis_config()
    create_gitignore(args.pkgname)
    setup_git(args.pkgname)


if __name__ == "__main__":
    main()
